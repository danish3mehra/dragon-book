Exercise 2.2.1: Consider the context free grammar

	S ->  S S +  |  S S *  |  a
		
	a) Show how the string aa+a* can be generated by this grammar.
	
		S ->  S S *
		  ->  S a *
		  ->  S S + a *
		  ->  a a + a *
	
	b) Construct a parse tree for this string.
	
			S			S			*
			|			|
		S 	S 	+		a
		|	|
		a	a
	
	c) What language does this grammar generate? Justify your answer.
	
		Postfix notation allowing for multiplication and addition.
	
Exercise 2.2.2: What language is generated by the following grammars?
	In each case justify your answer.
	
	a) S ->  0 S 1  |  0 1
		Binary numbers which satisfy the rules:
			- Always starting with 0.
			- Always ending with 1.
			- 0 is always to the left of another 0.
			- 1 is always to the right of another 1.
			- There will be a single 0 to the left of a 1.
	
	b) S ->  + S S  |  - S S  |  a
		Prefix notation for addition and subtraction.
	
	c) S ->  S ( S ) S  |  ϵ
		Brackets which satisfy the rules:
			- Always contains atleast one (), or nothing.
			- Bracket groups may be placed beside one another, ie. ()(), in groups of
				one or more.
			- Brackets may be nested within groups, zero or more times. ie. (())(((())))()
	
	d) S ->  a S b S  |  b S a S  |  ϵ
		a's and b's which satisfy the rules:
			- Always contains atleast one a and b, on either side of each other, or nothing.
			- ab or ba may be added at any location.
	
	e) S ->  a  |  S + S  |  S S  |  S *  |  ( S )
		A mixture between infix and postfix for multiplication, addition, and bracket nesting,
			which satisfies the rules:
			- Always contains atleast the letter a.
			- The letter a constitutes a valid statement.
			- Valid statements may be separated by a +,
				which also constitutes a valid statement.
			- Valid statements may be followed by a *,
				which also constitutes a valid statement.
			- Valid statements may be placed next to each other,
				which also constitutes a valid statement.
			- Valid statements may be nested in brackets,
				which also constitutes a valid statement.
	
Exercise 2.2.3: Which of the grammars in Exercise 2.2.2 are ambiguous ?

	a) is unambiguous.
	b) is unambiguous.
	c) is ambiguous.
		S ->  S ( S ) S
		  ->  S ( S ) ( S ) S
		  (which side is it on ?)
	d) is ambiguous.
		S ->  a S b S  |  b S a S  |  ϵ
		  ->  a b ϵ a ϵ b ϵ
		  ->  a ϵ b a ϵ b ϵ
		  (which method was used?)
	e) is ambiguous
		S ->  S S
		  ->  S S S
		  (which side is it on?)

Exercise 2.2.4: Construct unambiguous context-free grammars for each of the following
	languages. In each case show that your grammar is correct.
	
	a) Arithmetic expressions in postfix notation.
		expr ->  expr expr op  |  number
		op ->  +  |  -  |  *  |  /
	
	b) Left-associative lists of identifiers separated by commas.
		list ->  list , id  |  id
	
	c) Right-associative lists of identifiers separated by commas.
		list ->  id , list  |  id
	
	d) Arithmetic expressions of integers and identifiers with the four binary operators
		+, -, *, /.
		
		expr ->  type + md_expr  |  type - md_expr  |  md_expr
		md_expr -> md_expr * type  |  md_expr / type  |  type
		type ->  identifier  |  number  |  ( expr )
		
	!e) Add unary plus and minus to the arithmetic operators of (d).
		expr ->  type + md_expr  |  type - md_expr  |  md_expr
		md_expr -> md_expr * unary  |  md_expr / unary  |  unary
		unary ->  - type  |  + type  |  type
		type ->  identifier  |  number  |  ( expr )
	
Exercise 2.2.5:

	a) Show that all binary strings generated by the following grammar have values
		divisible by 3.
		Hint. Use induction on the number of nodes in a parse tree.
		
		num ->  11  |  1001  |  num 0  |  num num
		
		11 = 3 (divisible by 3)
		
		1001 = 9 ( divisible by 3)
		
		Any binary number bit shifted left by one,
			(or in other words, having an extra 0 on the end), is the same as multiplying
			by 2. Therefore, num ->  num 0 still satisfies the rule.
		
		Any binary number placed next to the other is the same as:
			number = lhs * (2 ^ sizeof(rhs)) + rhs
			Assuming rhs = any number divisible by 3, lhs = 11 or 3
				number = 3 * (2 ^ sizeof(rhs)) + rhs
			Assuming rhs = any number divisible by 3, lhs = 1001 or 9
				number = 9 * (2 ^ sizeof(rhs)) + rhs
			One will notice that both of these numbers are clearly divisible by 3
				as they follow the rule:
				number = 9x + 3y
					where x = 2 ^ sizeof(rhs)
					where y = (any number divisible by 3) / 3
				or even number = 3(3x + y)
		
	b) Does the grammar generate all binary strings with values divisible by 3?
		No it does not. 10101=21 cannot be generated yet it is still divisible by 3.
	
Exercise 2.2.6: Construct a context-free grammar for roman numerals.

	(Works up to 3999)
	numeral ->  thousand hundred ten digit
	c ->  C  |  C C  |  C C C  |  ϵ
	x ->  X  |  X X  |  X X X  |  ϵ
	i ->  I  |  I I  |  I I I  |  ϵ
	thousand ->  M  |  M M  |  M M M  |  ϵ
	hundred ->  c  |  C D  |  D c  |  C M
	ten ->  x  |  X L  |  L x  |  X C
	digit ->  i  |  I V  | V i  | I X
